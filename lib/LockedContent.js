"use strict";

const crypto = require('crypto');

const _ = require("lodash");
const NodeRSA = require('node-rsa');

const Keychain = require('./Keychain');
const ExtendableError = require('./ExtendableError');




class LockedContentError extends ExtendableError
{}
class KeyMatchError extends LockedContentError
{}
class ContentAuthenticityError extends LockedContentError
{}
class ContentDecryptionError extends LockedContentError
{}

class LockedContent
{
    constructor()
    {
        this.erase();
    }

    erase()
    {
        /**
         * Content that was locked down with a symmetric key
         */
        this.encryptedContent = undefined;
        /**
         * Used to verify that the content was encrypted by a valid writeKey
         */
        this.encryptedContentSignature = undefined;
        this.encryptedSymmetricKey = undefined;
        /**
         * Used to verify that the symmetric key was generated by a valid writeKey
         */
        this.encryptedSymmetricKeySignature = undefined;
    }

    /**
     * Takes content and stores a locked down version of the content as a new Instance of LockedContent
     * @param {*} content
     * @param {NodeRSA|Keychain} options.keys
     * @param {boolean} [options.debugFailEncryption=false]
     * @return {LockedContent|undefined}
     */
    static lock(content, options)
    {
        options = _.extend({
            throwError: true
        }, options);

        let keychain = Keychain.makeKeychainFrom(options.keys);
        if(_.isNull(keychain)) {
            //Unsupported keys
            throw new TypeError("options.keys is not of any supported type");
        }
        let keypair = keychain.getPreferredWriteKey();

        let locked = new LockedContent();

        try {
            if(options.debugFailEncryption)
            { //noinspection ExceptionCaughtLocallyJS
                throw new Error("Debug Encryption Failure");
            }

            let symmetricKey = crypto.randomBytes(keypair.getMaxMessageSize());

            locked.encryptedSymmetricKey = keypair.encryptPrivate(symmetricKey);
            locked.encryptedSymmetricKeySignature = keypair.sign(locked.encryptedSymmetricKey);

            let cipher = crypto.createCipher('aes192', symmetricKey);
            let encryptedContent = cipher.update(content);
            locked.encryptedContent = Buffer.concat([encryptedContent, cipher.final()]);
            locked.encryptedContentSignature = keypair.sign(locked.encryptedContent);
        } catch(e)
        {
            throw new Error("Could not encrypt content: " + e);
        }

        return locked;
    }

    /**
     * @param {NodeRSA|Keychain} options.keys
     * @param {boolean} [options.throwError=true] - if false, does not throw any errors but instead returns undefined
     * @param {boolean} [options.debugFailDecryption=false]
     * @throws {TypeError}
     * @throws {LockedContent.KeyMatchError}
     * @throws {LockedContent.ContentAuthenticityError}
     * @throws {LockedContent.ContentDecryptionError}
     * @return {*|undefined}
     */
    unlock(options)
    {
        options = _.extend({
            throwError: true
        }, options);

        let keychain = Keychain.makeKeychainFrom(options.keys);
        if(_.isNull(keychain)) {
            //Unsupported keys
            if(!options.throwError)return;
            throw new TypeError("options.keys is not of any supported type");
        }

        //Fetch the keypair that verifies the symmetric keys signature
        let keypair = keychain.getVerifyingKeypair(this.encryptedSymmetricKey, this.encryptedSymmetricKeySignature);
        if(_.isUndefined(keypair))
        {
            if(!options.throwError)return;
            throw new KeyMatchError("No matching keypair for this lock given (symmetric key could not be verified)");
        }
        //Check if the content has been signed by the same writers key as the symmetric key.
        let contentIsAuthentic = keypair.verify(this.encryptedContent, this.encryptedContentSignature);
        if(!contentIsAuthentic)
        {
            if(!options.throwError)return;
            throw new ContentAuthenticityError("Authenticity of the content could not be verified");
        }
        //Everything seems to be in order, so decrypt the symmetric key to finally decrypt the content
        let symmetricKey = keypair.decryptPublic(this.encryptedSymmetricKey);

        let decryptedContent;
        try {
            if(options.debugFailDecryption)
            { //noinspection ExceptionCaughtLocallyJS
                throw new Error("Debug Decryption Failure");
            }
            let cipher = crypto.createDecipher('aes192', symmetricKey);
            decryptedContent = cipher.update(this.encryptedContent);
            decryptedContent = Buffer.concat([decryptedContent, cipher.final()]);
        } catch(e)
        {
            if(!options.throwError)return;
            throw new ContentDecryptionError("Could not authentically decrypt content: " + e);
        }

        return decryptedContent;
    }
}

LockedContent.KeyMatchError = KeyMatchError;
LockedContent.ContentAuthenticityError = ContentAuthenticityError;
LockedContent.ContentDecryptionError = ContentDecryptionError;


module.exports = LockedContent;