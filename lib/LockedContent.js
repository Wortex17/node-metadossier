"use strict";

const crypto = require('crypto');

const _ = require("lodash");
const NodeRSA = require('node-rsa');

const Keychain = require('./Keychain');

class LockedContent
{
    constructor()
    {
        this.erase();
    }

    erase()
    {
        /**
         * Content that was locked down with a symmetric key
         */
        this.encryptedContent = undefined;
        /**
         * Used to verify that the content was encrypted by a valid writeKey
         */
        this.encryptedContentSignature = undefined;
        this.encryptedSymmetricKey = undefined;
        /**
         * Used to verify that the symmetric key was generated by a valid writeKey
         */
        this.encryptedSymmetricKeySignature = undefined;
    }

    /**
     * Takes content and stores a locked down version of the content as a new Instance of LockedContent
     * @param {*} content
     * @param {NodeRSA|Keychain} options.keys
     * @param {boolean} [options.debugFailEncryption]
     * @return {LockedContent}
     */
    static lock(content, options)
    {
        options = _.extend({}, options);

        let givenKeys = options.keys;
        let keypair;
        if(givenKeys instanceof Keychain) {
            keypair = givenKeys.getPreferredWriteKey();
        } else if(givenKeys instanceof NodeRSA) {
            keypair = givenKeys;
        } else {
            //Unsupported keys
            throw new TypeError("options.keys is not of any supported type");
        }

        let locked = new LockedContent();

        try {
            if(options.debugFailEncryption)
            { //noinspection ExceptionCaughtLocallyJS
                throw new Error("Debug Encryption Failure");
            }

            let symmetricKey = crypto.randomBytes(keypair.getMaxMessageSize());

            locked.encryptedSymmetricKey = keypair.encryptPrivate(symmetricKey);
            locked.encryptedSymmetricKeySignature = keypair.sign(locked.encryptedSymmetricKey);

            let cipher = crypto.createCipher('aes192', symmetricKey);
            let encryptedContent = cipher.update(content);
            locked.encryptedContent = Buffer.concat([encryptedContent, cipher.final()]);
            locked.encryptedContentSignature = keypair.sign(locked.encryptedContent);
        } catch(e)
        {
            throw new Error("Could not encrypt content: " + e);
        }

        return locked;
    }

    /**
     * @param {NodeRSA|Keychain} options.keys
     * @return {*}
     */
    unlock(options)
    {
        options = _.extend({}, options);

        let givenKeys = options.keys;
        let keychain;
        if(givenKeys instanceof Keychain) {
            //Already a kechain
            keychain = givenKeys;
        } else if(givenKeys instanceof NodeRSA) {
            //Create a new keychain with only the given key in it, to streamline the following code
            keychain = new Keychain();
            keychain.addKeypair(givenKeys)
        } else {
            //Unsupported keys
            throw new TypeError("options.keys is not of any supported type");
        }

        //Fetch the keypair that verifies the symmetric keys signature
        let keypair = keychain.getVerifyingKeypair(this.encryptedSymmetricKey, this.encryptedSymmetricKeySignature);
        if(_.isUndefined(keypair))
        {
            throw new Error("No matching keypair for this lock given (symmetric key could not be verified)");
        }
        //Check if the content has been signed by the same writers key as the symmetric key.
        let contentIsAuthentic = keypair.verify(this.encryptedContent, this.encryptedContentSignature);
        if(!contentIsAuthentic)
        {
            throw new Error("Authenticity of the content could not be verified");
        }
        //Everything seems to be in order, so decrypt the symmetric key to finally decrypt the content
        let symmetricKey = keypair.decryptPublic(this.encryptedSymmetricKey);

        let decryptedContent;
        try {
            let cipher = crypto.createDecipher('aes192', symmetricKey);
            decryptedContent = cipher.update(this.encryptedContent);
            decryptedContent = Buffer.concat([decryptedContent, cipher.final()]);
        } catch(e)
        {
            throw new Error("Could not authentically decrypt content: " + e);
        }

        return decryptedContent;
    }
}

module.exports = LockedContent;